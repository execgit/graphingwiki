#! /usr/bin/env python

import re
import sys
import os
import cPickle

# All different reference types
reftypes = ['Reference', 'seealso', 'Update', 'Obsolete', 'ReferenceFrom',
        'seealso', 'UpdateFrom', 'ObsoleteFrom']

typetext = {'Reference': 'References', 'ReferenceFrom': 'Referenced',
            'Obsolete': 'Obsoletes', 'ObsoleteFrom': 'Obsoleted',
            'Update': 'Updates', 'UpdateFrom': 'Updated'}

# Markers for the autogenerated section on the wikipage
autogen_marker = "## Autogenerated rfc data, please do not edit\n"
autogen_re = re.compile("^" + autogen_marker + ".+" + autogen_marker, re.M|re.S)

# Infile is a file generated by parserfcs.py
try:
    infile = file(sys.argv[2])
    data = cPickle.load(infile)
    infile.close()
    
    # Change to wiki path if so desired
    wikipath = sys.argv[1]
    os.chdir(wikipath)
except:
    print "Usage: " + sys.argv[0] + " <path-to-wiki> " + \
          " <path-to-rfcdata-pickle> "
    raise

# Does links, corrects seealso and gathers all links into a dict
def do_references(refs, data, type):
    newrefs = {type: []}
    for item in data:
        newrefs[type].append("[:rfc%s:%s: rfc%s]" % (item, type, item))
    if refs.has_key(type):
        refs[type] += newrefs[type]
    else:
        refs[type] = newrefs[type]

    return refs

# Go through all rfc:s
for nr in data:
    # print "Processing rfc " + nr
    text = autogen_marker
    refs = {}
    for type in sorted(data[nr]):
        # Gather references and metadata
        if type in reftypes:
            if type == 'seealso':
                refs = do_references(refs, data[nr][type], 'Reference')
                refs = do_references(refs, data[nr][type], 'ReferenceFrom')
            else:
                refs = do_references(refs, data[nr][type], type)
        elif type == 'number':
            text += "[[MetaData(" + type + "," + data[nr][type] + \
                    ",hidden)]]\n"
        else:
            text += "[[MetaData(" + type + "," + data[nr][type] + ")]]\n"

    # Add references to text in order
    for type in sorted(refs):
        text += typetext[type] + ": "
        for i in range(0, len(refs[type]), 3):
            text += ' '.join(refs[type][i:i+3]) + "\n"
        text += "\n"
    text += autogen_marker

    rfcdir = os.path.join('rfc' + nr)
    # If the autogenerated files already exist, so just revising
    if os.path.isdir(rfcdir):
        f = file(os.path.join(rfcdir, 'current'))
        ver = f.read().rstrip()
        f.close()
        f = file(os.path.join(rfcdir, 'revisions', ver))
        rfcdata = f.read()
        f.close()

        # replace previous autogenerated with new ones
        if rfcdata != text:
            rfcdata = autogen_re.sub(text, rfcdata)
            f = file(os.path.join(rfcdir, 'revisions', ver), 'w')
            f.write(rfcdata)
            f.close()
    else:
        # make new dirs
        revdir, version = os.path.join(rfcdir, 'revisions'), "%08d" % 1
        os.makedirs(revdir)
        f = file(os.path.join(rfcdir, 'current'), 'w')
        f.write(version)
        f.close()

        f = file(os.path.join(revdir, version), 'w')
        f.write(text)
        f.close()
        # touch graphdata.pickle, so that rehashgraphs.py hits the page
        f = file(os.path.join(rfcdir, 'graphdata.pickle'), 'w')
        f.close()
